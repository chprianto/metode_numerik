# membentuk matriks A
pred <- cbind(intercept=1, Girth=trees$Girth, Height=trees$Height)
head(A)
resp<- trees$Volume
head(resp)
A <- t(pred) %*% pred
b <- t(A) %*% Volume
b <- t(pred) %*% resp
(x <- gauss_jordan(A, b))
Ab <- cbind(A,b)
(x <- gauss_jordan(Ab))
# metode LU
lu_solve(A,b)
lu_solve <- function(a, b=NULL){
m <- nrow(a)
n <- ncol(a)
piv <- 1
# membentuk matriks identitas P dan L
P <- L <- diag(n)
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return(list(P = P, L = L, U = a))
}
}
# jika elemen diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr){
a <- swap_row(a, i, row_curr)
P <- swap_row(P, i, row_curr)
}
# pembentukan matriks L dan U
for(j in row_curr:m)
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
# matriks U
a <- replace_row(a, row_curr, j, -k)
# pengisian elemen matriks L
L[j, piv] <- k
}
piv <- piv + 1
}
}
# penyelesaian persamaan linier
if(is.null(b)){
return(list(P = P, L = L, U = a))
}else{
# forward substitution
t <- forwardsolve(L, b)
# backward substitution
x <- backsolve(a, t)
return(list(P = P, L = L, U = a, result=x))
}
}
# metode LU
lu_solve(A,b)
# metode Cholesky
cholesky_solve(A,b)
cholesky_solve <- function(a, b=NULL){
m <- nrow(a)
# membentuk matriks L dengan elemen nol
L = diag(0,m)
# Perhitungan elemen matriks L
for(i in 1:m){
for(k in 1:i){
p_sum <- 0
for(j in 1:k)
p_sum <- p_sum + L[j,i]*L[j,k]
# Pehitungan elemen diagonal utama
if(i==k)
L[k,i]<-sqrt(a[i,i]-p_sum)
else
L[k,i]<-(a[k,i]-p_sum)/L[k,k]
}
}
# Perhitungan elemn matriks L*
tL <- t(L)
# penyelesaian persamaan linier
if(is.null(b)){
return(list(L = L, tL = tL, a = a))
}else{
# forward substitution
t <- forwardsolve(L, b)
# backward substitution
x <- backsolve(tL, t)
return(list(L = L, tL = tL, a = a, result=x))
}
}
# metode Cholesky
cholesky_solve(A,b)
# fungsi solve()
solve(A,b)
lm(Volume~Girth+Height, data=trees)
gauss_jordan <- function (a, b=NULL){
m <- nrow (a)
n <- ncol (a)
piv <- 1
if(is.null(b)){
a <- cbind(a,b)}
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return (a)
}
}
# jika diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr)
a <- swap_row(a, i, row_curr)
# proses pembentukan matriks reduced row echelon form
piv_val <- a[row_curr , piv]
a <- scale_row (a, row_curr , 1 / piv_val)
for(j in 1: m){
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
a <- replace_row (a, row_curr, j, -k)
}
}
piv <- piv + 1
}
}
return (a)
}
gauss_jordan <- function (a, b=NULL){
m <- nrow (a)
n <- ncol (a)
piv <- 1
if(is.null(b)){
a <- cbind(a,b)}
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return (a)
}
}
# jika diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr)
a <- swap_row(a, i, row_curr)
# proses pembentukan matriks reduced row echelon form
piv_val <- a[row_curr , piv]
a <- scale_row (a, row_curr , 1 / piv_val)
for(j in 1: m){
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
a <- replace_row (a, row_curr, j, -k)
}
}
piv <- piv + 1
}
}
return (a[,n])
}
(m <- matrix(c(1,2,1,4,3,8), nrow=2))
gauss_jordan(m)
gauss_jordan <- function (a){
m <- nrow (a)
n <- ncol (a)
piv <- 1
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return (a)
}
}
# jika diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr)
a <- swap_row(a, i, row_curr)
# proses pembentukan matriks reduced row echelon form
piv_val <- a[row_curr , piv]
a <- scale_row (a, row_curr , 1 / piv_val)
for(j in 1: m){
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
a <- replace_row (a, row_curr, j, -k)
}
}
piv <- piv + 1
}
}
return (a)
}
library(knitr)
img1_path <- "./images/reaktor.jpeg"
include_graphics(img1_path)
(A <- matrix(c(6,-3,0,0,-3,
0,3,-1,-1,-1,
-1,0,9,-8,0,
0,0,0,11,0,
0,0,0,-2,4),nrow=5))
(b <- c(50,0,160,0,0))
gauss_jordan(cbind(A,b))
lu_solve(A,b)
lu_solve <- function(a, b=NULL){
m <- nrow(a)
n <- ncol(a)
piv <- 1
# membentuk matriks identitas P dan L
P <- L <- diag(n)
# cek elemen diagonal utama apakah bernilai nol
for(row_curr in 1:m){
if(piv <= n){
i <- row_curr
while(a[i, piv] == 0 && i < m){
i <- i + 1
if(i > m){
i <- row_curr
piv <- piv + 1
if(piv > n)
return(list(P = P, L = L, U = a))
}
}
# jika elemen diagonal utama bernilai nol,lakukan row swapping
if(i != row_curr){
a <- swap_row(a, i, row_curr)
P <- swap_row(P, i, row_curr)
}
# pembentukan matriks L dan U
for(j in row_curr:m)
if(j != row_curr){
k <- a[j, piv]/a[row_curr, piv]
# matriks U
a <- replace_row(a, row_curr, j, -k)
# pengisian elemen matriks L
L[j, piv] <- k
}
piv <- piv + 1
}
}
# penyelesaian persamaan linier
if(is.null(b)){
return(list(P = P, L = L, U = a))
}else{
# forward substitution
t <- forwardsolve(L, b)
# backward substitution
x <- backsolve(a, t)
return(list(P = P, L = L, U = a, result=x))
}
}
lu_solve(A,b)
jacobi(A,b, maxiter=100)
jacobi <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
Dinv <- diag(1/diag(a))
R <- a-diag(diag(a))
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(maxiter>iter){
warning("iterasi maksimum tercapai")
}
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
gauss_seidel <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(maxiter>iter){
warning("iterasi maksimum tercapai")
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
jacobi(A,b, maxiter=100)
jacobi(A,b, maxiter=200)
jacobi(A,b, maxiter=200)
jacobi(A,b)
jacobi <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
Dinv <- diag(1/diag(a))
R <- a-diag(diag(a))
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(maxiter>iter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
gauss_seidel <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(maxiter>iter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
jacobi(A,b, maxiter=200)
jacobi(A,b, maxiter=100)
jacobi <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
Dinv <- diag(1/diag(a))
R <- a-diag(diag(a))
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
gauss_seidel <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
if(is.null(maxiter)){
while(sqrt(sum(x_new-x)^2)>tol){
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}else{
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
}
jacobi(A,b, maxiter=100)
gauss_seidel(A,b, maxiter=200)
str(mtcars)
jacobi <- function(a, b, tol=1e-7, maxiter=100){
n <- length(b)
iter <- 0
Dinv <- diag(1/diag(a))
R <- a-diag(diag(a))
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Dinv %*% (b - R %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
(A <- matrix(c(5,2,1,2,7,3,3,4,8), 3))
(b <- c(40,39,55))
(x <- rep(0,3))
jacobi(A,b)
gauss_seidel <- function(a, b, tol=1e-7, maxiter=NULL){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
gauss_seidel(A,b)
gauss_seidel <- function(a, b, tol=1e-7, maxiter=100){
n <- length(b)
iter <- 0
L <- U <- a
L[upper.tri(a, diag=FALSE)] <- 0
U[lower.tri(a, diag=TRUE)] <- 0
Linv <- solve(L)
x <- rep(0,n)
x_new <- rep(tol, n)
while(sqrt(sum(x_new-x)^2)>tol){
if(iter>maxiter){
warning("iterasi maksimum tercapai")
break
}
x <- x_new
x_new <- Linv %*% (b - U %*% x)
iter <- iter+1
}
return(list(X = x_new, iter=iter))
}
gauss_seidel(A,b)
library(Rcmdr)
install.packages("Rcmdr")
library(Rcmdr)
library(ggplot2)
install.packages("tidyverse")
library(Rcmdr)
